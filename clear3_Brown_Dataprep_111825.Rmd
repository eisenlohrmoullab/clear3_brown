---
title: "Clear3_Brown_Dataprep"
output: html_document
date: "2025-09-24"
---

https://eisenlohrmoullab.github.io/menstrualcycleR/articles/menstrualcycleR-overview.html

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

``` {r}
df <- readRDS("data/clear3daily_oura.rds")
```

```{r corrheatmap, echo=TRUE, message=FALSE, warning=FALSE, fig.width=9, fig.height=6}
# ===================================================================
# 1. Load Required Libraries
# ===================================================================
library(tidyverse)
library(rmcorr)
library(performance)
library(lme4)
library(ggplot2)
library(menstrualcycleR)

#names(df)
```

# Checking to see people with at least five days in each phase

``` {r}

df %>%
  filter(!is.na(Oura_Activity_steps), scaled_cycleday_impute != 0) %>%
  group_by(id) %>%
  summarise(
    follicular = sum(scaled_cycleday_impute > 0 & scaled_cycleday_impute < 1),
    luteal     = sum(scaled_cycleday_impute < 0 & scaled_cycleday_impute > -1)
  ) %>%
  filter(follicular >= 5, luteal >= 5) %>%
  nrow()

```

# Make Figure 1. ICCs, Between- and Within-Person Associations of Study Variables


```{r}
# ===================================================================
# 2. Define the Heatmap Generation Function (Final Version)
# ===================================================================
generate_correlation_heatmap <- function(
    data, outcome_vars, id_var, final_labels = NULL, # <-- New argument
    sig.level = 0.05,
    highlight_diag = TRUE,
    show_legend = TRUE,
    label_size = 4.6,
    diag_label_size = 6,
    subtitle_text = "Upper: Between-person (Spearman); Lower: Within-person (rmcorr); Diagonal: ICC"
) {
  # (The first part of the function is the same as the last version)
  n_vars <- length(outcome_vars)
  results_matrix <- matrix(NA, nrow = n_vars, ncol = n_vars,
                           dimnames = list(outcome_vars, outcome_vars))
  pval_matrix <- matrix(NA, nrow = n_vars, ncol = n_vars,
                        dimnames = list(outcome_vars, outcome_vars))
  
  summary_expressions <- purrr::map(outcome_vars, ~ rlang::quo(mean(!!rlang::sym(.x), na.rm = TRUE))) %>%
    rlang::set_names(outcome_vars)
    
  person_means <- data %>%
    group_by(!!rlang::sym(id_var)) %>%
    summarise(!!!summary_expressions, .groups = "drop")

  between_corr <- suppressWarnings(
    cor(person_means[, outcome_vars], method = "spearman", use = "pairwise.complete.obs")
  )

  for (i in 1:(n_vars - 1)) for (j in (i + 1):n_vars) {
    x <- person_means[[outcome_vars[i]]]
    y <- person_means[[outcome_vars[j]]]
    if (sum(!is.na(x) & !is.na(y)) > 2) {
      test <- suppressWarnings(cor.test(x, y, method = "spearman"))
      results_matrix[i, j] <- between_corr[i, j]
      pval_matrix[i, j] <- test$p.value
    }
  }

  for (i in 1:n_vars) {
    var <- outcome_vars[i]
    fml <- as.formula(paste0("`", var, "` ~ 1 + (1|`", id_var, "`)"))
    if (sum(!is.na(data[[var]])) > 1) {
      model_fit <- try(lmer(fml, data = data), silent = TRUE)
      if (!inherits(model_fit, "try-error")) {
        icc_val <- performance::icc(model_fit)$ICC_adjusted
        results_matrix[i, i] <- icc_val
        pval_matrix[i, i] <- 0
      }
    }
  }

  for (i in 2:n_vars) for (j in 1:(i - 1)) {
    var1 <- outcome_vars[i]; var2 <- outcome_vars[j]
    rmcorr_data <- data %>% select(all_of(c(id_var, var1, var2))) %>% drop_na()
    if (nrow(rmcorr_data) > 2) {
      rmcorr_result <- rmcorr::rmcorr(participant = id_var, measure1 = var1, measure2 = var2, dataset = rmcorr_data)
      results_matrix[i, j] <- rmcorr_result$r
      pval_matrix[i, j] <- rmcorr_result$p
    }
  }

  within_corr_matrix <- results_matrix
  within_corr_matrix[upper.tri(within_corr_matrix, diag = TRUE)] <- 0
  dist_matrix <- as.dist(1 - abs(within_corr_matrix))
  hclust_obj <- hclust(dist_matrix, method = "ward.D2")
  corr_order <- rownames(within_corr_matrix)[hclust_obj$order]

  results_matrix_ordered <- results_matrix[corr_order, corr_order]
  pval_matrix_ordered    <- pval_matrix[corr_order, corr_order]

  plot_df <- as.data.frame(as.table(results_matrix_ordered))
  names(plot_df) <- c("Var1", "Var2", "value")
  plot_df$p.value <- as.vector(pval_matrix_ordered)
  plot_df$Var1 <- factor(plot_df$Var1, levels = rev(corr_order))
  plot_df$Var2 <- factor(plot_df$Var2, levels = corr_order)

  no_leading_zero <- function(x) {
    ifelse(is.na(x), NA_character_, sub("^(-?)0\\.", "\\1.", sprintf("%.2f", x)))
  }

  plot_df <- plot_df %>%
    mutate(
      is_diag = as.character(Var1) == as.character(Var2),
      is_sig  = p.value < sig.level,
      label   = no_leading_zero(value)
    )

  diag_df    <- plot_df %>% filter(is_diag)
  sig_df     <- plot_df %>% filter(!is_diag & is_sig)
  nonsig_df  <- plot_df %>% filter(!is_diag & !is_sig)

  p <- ggplot() +
    geom_tile(data = plot_df %>% filter(!is_diag),
              aes(x = Var2, y = Var1, fill = value), color = "gray70", linewidth = 0.5) +
    geom_tile(data = diag_df, aes(x = Var2, y = Var1),
              fill = "gray92", color = "gray70", linewidth = 0.5) +
    scale_fill_gradient2(low = "#6D9EC1", mid = "white", high = "#E46726",
                       midpoint = 0, limits = c(-1, 1), name = "Correlation") +
    labs(title = "Multilevel Correlation Matrix of Daily Outcomes", subtitle = subtitle_text) +
    theme_minimal(base_size = 14) +
    theme(
      plot.title    = element_text(hjust = 0.5, face = "bold", size = 20),
      plot.subtitle = element_text(hjust = 0.5, face = "italic", size = 12, margin = margin(b = 6)),
      axis.text.x   = element_text(angle = 45, vjust = 1, hjust = 1),
      axis.text.y   = element_text(face = "bold"),
      axis.title    = element_blank(),
      legend.position = if (show_legend) "right" else "none",
      panel.grid.major = element_blank()
    )

  p <- p +
    geom_text(data = sig_df, aes(x = Var2, y = Var1, label = label),
              fontface = "bold", color = "black", size = label_size, na.rm = TRUE) +
    geom_text(data = nonsig_df, aes(x = Var2, y = Var1, label = label),
              color = "gray40", size = label_size, na.rm = TRUE)

  if (highlight_diag && nrow(diag_df) > 0) {
    p <- p +
      geom_text(data = diag_df, aes(x = Var2, y = Var1, label = label),
                fontface = "bold", color = "#4B0082", size = diag_label_size, na.rm = TRUE)
  }
  
  # === NEW CODE TO RELABEL AXES AT THE END ===
  if (!is.null(final_labels)) {
    p <- p +
      scale_x_discrete(labels = final_labels) +
      scale_y_discrete(labels = final_labels)
  }
  # ===========================================

  return(p)
}
```

```{r}
# ===================================================================
# 3. Define Parameters and Run the Plot
# ===================================================================
# Technical names mapped to the desired "pretty" labels
corrplotlist <- c(
  "Oura_Activity_steps" = "Steps",
  "DRSP1_depblue" = "Depressed",
  "DRSP4_anxious" = "Anxious",
  "DRSP7b_irritable" = "Irritable",
  "physicalpain" = "Pain",
  "ASIQ9_wishdead" = "Passive SI",
  "wantedkill" = "Active SI"
)

# This assumes `cycle_df_scaled` exists in your environment
if (exists("df") && exists("corrplotlist")) {

  # === NEW: Create safe labels for calculation and a lookup table for plotting ===
  # 1. Create safe labels (e.g., "Hyperactive.Impulsive.Sx") for calculations
  safe_labels <- make.names(corrplotlist)
  
  # 2. Create a lookup table to map safe labels back to pretty labels
  label_lookup <- setNames(corrplotlist, safe_labels)
  # ===============================================================================

  # Prepare the data by renaming columns to the SAFE labels
  original_vars <- names(corrplotlist)
  plot_data <- df[, c("id", original_vars)]
  names(plot_data)[match(original_vars, names(plot_data))] <- safe_labels # Use safe_labels here

  # Call the function with the safe labels for calculation AND the lookup table for the final plot
  correlation_heatmap <- generate_correlation_heatmap(
    data = plot_data,
    outcome_vars = safe_labels, # Use safe_labels here
    id_var = "id",
    final_labels = label_lookup # Pass the lookup table for final relabeling
  )

  print(correlation_heatmap)
  
  #ggsave("output/correlation_heatmap.png", plot = correlation_heatmap, width = 9, height = 6)

} else {
  warning("Data 'df' or 'corrplotlist' not found.")
}
```

# Descriptvive step statistics and histograms 

```{r}

# Descriptive statistics
df %>%
  summarise(
    mean_steps = mean(Oura_Activity_steps, na.rm = TRUE),
    median_steps = median(Oura_Activity_steps, na.rm = TRUE),
    sd_steps = sd(Oura_Activity_steps, na.rm = TRUE),
    min_steps = min(Oura_Activity_steps, na.rm = TRUE),
    max_steps = max(Oura_Activity_steps, na.rm = TRUE)
  )

# Histogram
dailysteps_histogram <- ggplot(df, aes(x = Oura_Activity_steps)) +
  geom_histogram(binwidth = 1000, fill = "lavender", color = "black") +
  labs(
    title = "Histogram of Daily Steps",
    x = "Steps",
    y = "Count"
  ) +
  theme_minimal()

dailysteps_histogram

#ggsave("output/dailysteps_histogram.png", plot = dailysteps_histogram, width = 6, height = 4)


# Compute average steps per person
person_means <- df %>%
  group_by(id) %>%
  summarise(mean_steps_person = mean(Oura_Activity_steps, na.rm = TRUE)) %>%
  ungroup()

# Count unique ids
n_ids <- n_distinct(person_means$id)

# Histogram of person averages with n ids in the title
meanptsteps_histogram <- ggplot(person_means, aes(x = mean_steps_person)) +
  geom_histogram(binwidth = 1000, fill = "skyblue", color = "black") +
  labs(
    title = paste0("Histogram of Average Steps per Person (n = ", n_ids, " participants)"),
    x = "Average Steps",
    y = "Count"
  ) +
  theme_minimal()

#ggsave("output/meanptsteps_histogram.png", plot = meanptsteps_histogram, width = 6, height = 4)


```

### Cycle plots and GAMMs

# Step plot data avail

```{r step-plot, fig.height=8, fig.width=6, dpi=300}
?cycledata_check

# Analyze symptom data availability
data_available_info <- cycledata_check(
  df, 
  symptom_columns = c("Oura_Activity_steps")
)

# View results
#print(data_available_info$by_id)
#print(data_available_info$overall)
print(data_available_info$data_symptom_plots$Oura_Activity_steps)

#ggsave(
 # "output/step_data_avail.png",
  #plot = data_available_info$data_symptom_plots, 
  #width = 6,
  #height = 8,
  #dpi = 300
#)

```

# Cycle plots

```{r}
?cycle_plot

#means

step_plot_means <- cycle_plot(
  df,
  "Oura_Activity_steps", 
  centering = "menses",
  include_impute = TRUE,
  y_scale = "means",
  rollingavg = 5,
  align_val = "center",
  se = FALSE
)

print(step_plot_means)

#person-centered roll cycle plot w menstrual imputing
step_plot_pcroll <- cycle_plot(
  df,
  "Oura_Activity_steps", 
  centering = "menses",
  include_impute = TRUE,
  y_scale = "person-centered_roll",
  rollingavg = 5,
  align_val = "center",
  se = FALSE
)


print(step_plot_pcroll)

#ggsave("output/step_plot_pcroll.png", plot = step_plot_pcroll$plot)

#person-centered roll cycle plot w/o menstrual imputing (ni = no impute)

step_plot_pcrollni <- cycle_plot(
  df,
  "Oura_Activity_steps", 
  centering = "menses",
  include_impute = FALSE,
  y_scale = "person-centered_roll",
  rollingavg = 5,
  align_val = "center",
  se = FALSE
)

print(step_plot_pcrollni)
```

```{r}
df$steps_log = log(df$Oura_Activity_steps + 1) #log-transforming our outcome variable symptom

selected_vars <- c("cyclic_time_impute", "steps_log" )
datSX <- df[complete.cases(df[selected_vars]), ]

datSX$id = as.factor(datSX$id) # ALWAYS factor id before putting it in a gam formula

stepgamm1 <- mgcv::gam(
  steps_log ~ 
    s(cyclic_time_impute, bs = "cc") + #fixed slope
    s(id, bs = 're') + #random intercept
    s(cyclic_time_impute, id, bs=c("re", "cc")), #random slope
  knots= list(cyclic_time_impute = c(-1,1)), #telling it that this is ov
  data = datSX, 
  method = 'REML'
)

summary(stepgamm1)
```
The intercept represents the average value of the log-transformed symptom when all smooth terms are at their reference level.

s(cyclic time impute): low edf (.01) = less complex; less wiggles
  - Big p-value: not significant for nonlinearity at population level
  
s(id): look at differences in baseline symptoms; high edf and low p value = lots of baseline differencs in step count

s(cyclic_time_impute,id): looks at individual-specific deviations from average sx trajectory across cycle; high edf low p = significant nonlinear heterogeneity in sx changes throughout MC

R-sq.(adj) =  0.518: 53% of variance explained by model 
Deviance explained = 53%: 53% of the outcome variability is accounted for

REML = 4078.6: will need later for picking SMMs

n = 2793: observations in model after listwise deletion


Partitioning variance 
```{r}
var.part = gam.hp::gam.hp(stepgamm1)
var.part$hierarchical.partitioning 
```
                                         Unique Average.share Individual I.perc(%)
s(cyclic_time_impute,bs="cc")            0.0000        0.0003     0.0003      0.06
s(id,bs="re")                            0.4094        0.0558     0.4652     87.71
s(cyclic_time_impute,id,bs=c("re","cc")) 0.0090        0.0559     0.0649     12.24

Individual column output: 

s(cyclic_time_impute):
The fixed effect of cycle time explains .03% (0.0003) of total outcome variance. This shows that a teenytiny portion of outcome variation is captured by average, population-level cycle dynamics.

s(id, bs = “re”):
The random intercept explains 46.42% (0.4652) of total outcome variance. This reflects between-person differences in average outcome level—i.e., individual baselines not explained by cycle dynamics but could be explained by unmeasured trait variables (e.g. age, BMI).

s(cyclic_time_impute, id):
The random slope effect explains 5.6% (0.0559) of total outcome variance. This reflects individual differences in trajectories of the outcome across the cycle, above and beyond the average pattern.

# Variance

```{r}
# Step 1: Create the data frame
variance_df <- data.frame(
  Component = c("Fixed effect of the cycle", 
                "Random slope of the cycle", 
                "Within-person residual"),
  Term = c("s(cyclic_time_impute)", 
           "s(cyclic_time_impute, id)", 
           "Residual (1 - Deviance Explained)"),
  Proportion = c(0.0003, 0.4652, 0.0649)  
)

# Normalize 
variance_df <- variance_df %>%
  mutate(Percent = round(Proportion / sum(Proportion) * 100, 1),
         Label = paste0(Component, "\n", Percent, "%"))

# Step 2: Display table
knitr::kable(variance_df[, c("Component", "Term", "Proportion")], 
      col.names = c("Component", "Model Term", "Proportion of Within-Person Variance"))
```
Component	Model Term	Proportion of Within-Person Variance
Fixed effect of the cycle	s(cyclic_time_impute)	0.0003
Random slope of the cycle	s(cyclic_time_impute, id)	0.4652
Within-person residual	Residual (1 - Deviance Explained)	0.0649


```{r}
# Step 3: Create pie chart
ggplot(variance_df, ggplot2::aes(x = "", y = Proportion, fill = Label)) +
  geom_col(width = 1, color = "white") +
  coord_polar("y") +
  theme_void() +
  labs(title = "Total Within-person Variance") +
  theme(legend.title = element_blank())
```

```{r}
# Step 1: Create the data frame
variance_df <- data.frame(
  Component = c("Fixed effect of the cycle", 
                "Random slope of the cycle"),
  Term = c("s(cyclic_time_impute)", 
           "s(cyclic_time_impute, id)"),
  Proportion = c(.0003, 0.4652)  
)

# Normalize 
variance_df <- variance_df %>%
  mutate(Percent = round(Proportion / sum(Proportion) * 100, 1),
         Label = paste0(Component, "\n", Percent, "%"))

# Step 2: Display table
knitr::kable(variance_df[, c("Component", "Term", "Proportion")], 
      col.names = c("Component", "Model Term", "Within-Person Variance Accounted for by the Cycle"))
```
Component	Model Term	Within-Person Variance Accounted for by the Cycle
Fixed effect of the cycle	s(cyclic_time_impute)	0.0003
Random slope of the cycle	s(cyclic_time_impute, id)	0.4652

```{r}

# Step 3: Create pie chart
ggplot(variance_df,aes(x = "", y = Proportion, fill = Label)) +
  geom_col(width = 1, color = "white") +
  coord_polar("y") +
  theme_void() +
  labs(title = "Within-person Variance accounted for by the cycle") +
  theme(legend.title = element_blank())
```